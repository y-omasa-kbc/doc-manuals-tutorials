# **RESTful API 入門**

## **1\. はじめに**

### **1.1. APIとは？**

API (Application Programming Interface) とは、ソフトウェアやプログラム、ウェブサービス間で情報をやり取りするためのインターフェース（接点）のことです。APIを利用することで、あるソフトウェアの機能を別のソフトウェアから呼び出したり、データを連携したりすることが可能になります。

例えば、天気予報サイトが提供するAPIを利用すれば、自分のウェブサイトやアプリケーションに最新の天気情報を表示することができます。APIは、現代のソフトウェア開発において、異なるシステムを連携させるための重要な要素となっています。

### **1.2. RESTful APIとは？**

REST (Representational State Transfer) は、ウェブサービスを設計するためのアーキテクチャスタイルの一つです。そして、RESTの原則に従って設計されたAPIのことを「RESTful API」と呼びます。

RESTful APIは、HTTPプロトコルを利用して、リソース（情報やデータ）に対する操作（作成、読み取り、更新、削除など）を行います。シンプルで理解しやすく、柔軟性が高いことから、ウェブAPIの主流な設計スタイルとして広く採用されています。

## **2\. RESTの原則**

RESTful APIを設計する際には、以下の6つの原則に従うことが推奨されています。

### **2.1. クライアントサーバー分離 (Client-Server)**

クライアント（APIを利用する側）とサーバー（APIを提供する側）の関心事を分離します。クライアントはユーザーインターフェースやユーザー体験に注力し、サーバーはデータの保存や処理、ビジネスロジックに注力します。これにより、それぞれの開発を独立して進めることができ、柔軟性や拡張性が向上します。

### **2.2. ステートレス性 (Stateless)**

サーバーは、クライアントからの各リクエストを独立して処理します。つまり、サーバーはクライアントの状態を記憶しません（ステートレス）。リクエストに必要な情報はすべてリクエスト自体に含まれている必要があります。これにより、サーバーの実装がシンプルになり、スケーラビリティも向上します。

### **2.3. キャッシュ可能性 (Cacheable)**

クライアントは、サーバーからのレスポンスをキャッシュすることができます。これにより、同じリクエストに対して再度サーバーにアクセスする必要がなくなり、パフォーマンスの向上やサーバー負荷の軽減につながります。サーバーはレスポンスにキャッシュの可否や有効期限を示す情報を含めるべきです。

### **2.4. 統一インターフェース (Uniform Interface)**

RESTful APIは、リソースに対する操作方法を統一されたインターフェースで提供します。具体的には以下の4つの制約があります。

* **リソースの識別 (Identification of resources):** URI (Uniform Resource Identifier) を用いてリソースを一意に識別します。例えば、/users/123 はIDが123のユーザーリソースを表します。  
* **表現によるリソース操作 (Manipulation of resources through representations):** クライアントはリソースの表現（JSONやXMLなど）を取得し、その表現を操作することでリソースを更新したり削除したりします。  
* **自己記述的メッセージ (Self-descriptive messages):** 各メッセージ（リクエストやレスポンス）は、それ自体で内容を理解できる情報を含んでいるべきです。例えば、メディアタイプ（Content-Type ヘッダー）を指定することで、データ形式を明示します。  
* **HATEOAS (Hypermedia as the Engine of Application State):** レスポンスに、関連するリソースへのリンク情報（ハイパーメディア）を含めることで、クライアントは次に可能な操作を動的に発見できるようにします。

### **2.5. 階層化システム (Layered System)**

システムを階層構造にすることができます。クライアントは直接接続しているサーバーの先に、さらに別のサーバー（ロードバランサー、キャッシュサーバー、プロキシサーバーなど）が存在することを意識する必要はありません。これにより、セキュリティの向上や負荷分散などが実現できます。

### **2.6. コードオンデマンド (Code on Demand) \- オプション**

サーバーがクライアントに対して実行可能なコード（例: JavaScript）を送信し、クライアント側でそのコードを実行させることができるという原則です。これはオプションであり、必須ではありません。

## **3\. HTTPメソッド**

RESTful APIでは、リソースに対する操作をHTTPメソッドで表現します。代表的なHTTPメソッドは以下の通りです。

| HTTPメソッド | 説明 | 対応する操作 (CRUD) | 冪等性 | 安全性 |
| :---- | :---- | :---- | :---- | :---- |
| **GET** | リソースの取得 | Read | あり | あり |
| **POST** | リソースの新規作成、またはサブリソースの作成 | Create | なし | なし |
| **PUT** | リソースの更新（全体を置き換える） | Update | あり | なし |
| **DELETE** | リソースの削除 | Delete | あり | なし |
| **PATCH** | リソースの部分的な更新 | Update | なし | なし |

* **冪等性 (Idempotency):** 同じリクエストを複数回実行しても、結果が常に同じであることを意味します。  
  * **例 (GET):** /users/123 というリクエストを1回送信しても10回送信しても、常にユーザーIDが123のユーザー情報（またはリソースが存在しない場合はエラー）が返ってきます。サーバー側のリソース状態は変わりません。  
  * **例 (PUT):** ユーザーIDが123のユーザー情報を特定の内容（例: { "name": "山田太郎", "email": "taro@example.com" }）で更新するリクエスト /users/123 を1回送信した場合と、同じ内容で10回送信した場合とで、最終的なユーザー123の情報は同じ状態になります。1回目のリクエストでリソースが作成または更新され、2回目以降のリクエストでは既にその状態になっているため、結果としてリソースの状態は変わりません（ただし、更新日時などのメタデータは変わる可能性があります）。  
  * **例 (DELETE):** /users/123 というリソースを削除するリクエストを送信すると、1回目のリクエストでリソースが削除されます。2回目以降のリクエストでは、既にリソースが存在しないため「存在しない」という結果（例: 404 Not Found）が返ってきますが、サーバー側の「ユーザー123が存在しない」という状態は変わりません。  
  * **冪等でない例 (POST):** /users に新しいユーザーを作成するリクエストを送信すると、送信するたびに新しいユーザーが作成される可能性があります（例: ユーザーIDが自動採番される場合など）。そのため、同じリクエストを複数回実行すると、結果として複数の異なるリソースが作成されることになり、冪等ではありません。  
* **安全性 (Safety):** リクエストを実行しても、サーバー側のリソース状態に影響を与えない（副作用がない）ことを意味します。GETメソッドがこれに該当します。

**補足:**

* POST は冪等ではありません。同じリクエストを複数回実行すると、新しいリソースが複数作成される可能性があります。  
* PATCH はリソースの一部のみを更新する場合に使用されます。PUT はリソース全体を置き換えるため、更新しないフィールドも送信する必要があります。PATCHの冪等性は、操作の内容に依存します。例えば、「カウンターを1増やす」という操作は冪等ではありませんが、「特定のフィールドの値を"X"にする」という操作は冪等です。

## **4\. ステータスコード**

サーバーは、クライアントからのリクエストの結果をHTTPステータスコードで返します。ステータスコードは3桁の数字で構成され、最初の1桁でレスポンスの種類を示します。

* **1xx (Informational):** リクエスト処理中  
* **2xx (Successful):** リクエスト成功  
  * 200 OK: リクエスト成功（GET, PUT, PATCH など）  
  * 201 Created: リソースの作成成功（POST など）  
  * 204 No Content: リクエスト成功、レスポンスボディなし（DELETE など）  
* **3xx (Redirection):** リダイレクト  
* **4xx (Client Error):** クライアント側のエラー  
  * 400 Bad Request: リクエストが無効（パラメータ不足など）  
  * 401 Unauthorized: 認証が必要  
  * 403 Forbidden: アクセス権限がない  
  * 404 Not Found: リソースが見つからない  
* **5xx (Server Error):** サーバー側のエラー  
  * 500 Internal Server Error: サーバー内部でエラーが発生  
  * 503 Service Unavailable: サービス利用不可（メンテナンス中など）

クライアントは、このステータスコードを見て処理を分岐させます。

## **5\. エンドポイント設計**

エンドポイントとは、APIにアクセスするためのURIのことです。分かりやすく、直感的なエンドポイントを設計することが重要です。

### **5.1. リソース指向**

エンドポイントは、操作（動詞）ではなく、リソース（名詞）を中心に設計します。リソースとは、APIを通じて操作したい対象（データや情報）のことです。

* **良い例:**  
  * /users : 全ユーザーのリスト（コレクションリソース）  
  * /users/123 : IDが123の特定のユーザー（単一リソース）  
  * /users/123/posts : IDが123のユーザーが投稿した記事のリスト  
  * /products : 全商品のリスト  
  * /products/abc : IDがabcの特定の商品  
  * /orders/789/items : 注文IDが789の注文に含まれる商品のリスト

これらの例では、URIが「何の情報か」を明確に示しています。操作（取得、作成、更新、削除）はHTTPメソッド（GET, POST, PUT, DELETE）で表現します。

* **悪い例:**  
  * /getUsers (GETメソッドの操作がURIに含まれている)  
  * /createUser (POSTメソッドの操作がURIに含まれている)  
  * /updateProductById?id=abc (PUTやPATCHメソッドの操作がURIに含まれ、パラメータでリソースを特定しようとしている)  
  * /deleteOrderItems?orderId=789 (DELETEメソッドの操作がURIに含まれている)

これらの悪い例では、URIに動詞が含まれており、リソースが何であるかが直感的に分かりにくくなっています。RESTの原則では、URIはリソースを指し示す名詞であるべきです。

**なぜリソース指向が良いのか？**

* **直感的で分かりやすい:** URIを見るだけで、どのような情報にアクセスしようとしているのかが理解しやすくなります。  
* **統一性がある:** HTTPメソッドと組み合わせることで、リソースに対する操作が一貫した方法で表現できます。  
* **拡張性が高い:** 新しい操作を追加する場合でも、既存のURI構造を変更する必要が少なく、HTTPメソッドの追加で対応できることが多いです。

### **5.2. 命名規則**

* **複数形の名詞:** リソースのコレクションを表す場合は複数形を使用します (例: /users, /products)。  
* **小文字:** URIには小文字を使用することが一般的です。  
* **単語の区切り:** ハイフン (-) またはアンダースコア (\_) を使用します。RESTful APIではハイフンが推奨されることが多いです (例: /user-profiles)。

### **5.3. バージョニング**

APIは将来的に変更される可能性があるため、バージョニングを行うことが推奨されます。バージョニングの方法にはいくつかあります。

* **URIに含める:** /v1/users, /api/v2/products (最も一般的)  
* **クエリパラメータに含める:** /users?version=1  
* **カスタムヘッダーに含める:** Accept: application/vnd.example.v1+json

## **6\. リクエストとレスポンス**

### **6.1. ヘッダー (HTTP Headers)**

HTTPヘッダーには、リクエストやレスポンスに関する付加的な情報が含まれます。

* **リクエストヘッダーの例:**  
  * Authorization: 認証情報 (例: APIキー、トークン)  
  * Content-Type: リクエストボディのデータ形式 (例: application/json)  
  * Accept: クライアントが受け入れ可能なレスポンスのデータ形式 (例: application/json)  
* **レスポンスヘッダーの例:**  
  * Content-Type: レスポンスボディのデータ形式 (例: application/json)  
  * Cache-Control: キャッシュの制御情報  
  * Location: リソースが作成されたURI (ステータスコード 201 Created の場合など)

### **6.2. ボディ (HTTP Body)**

リクエストボディやレスポンスボディには、実際のデータが含まれます。データ形式としては、JSON (JavaScript Object Notation) が最も一般的に使用されます。XMLも使用されることがあります。

**JSONレスポンスの例 (GET /users/123):**
```
{  
  "id": 123,  
  "username": "taro\_yamada",  
  "email": "taro@example.com",  
  "created\_at": "2023-05-01T10:00:00Z"  
}
```
## **7\. RESTful APIのメリットとデメリット**

### **7.1. メリット**

* **シンプルさ:** HTTPプロトコルをベースにしているため、理解しやすく実装も比較的容易です。  
* **スケーラビリティ:** ステートレス性により、サーバーの負荷分散が容易で、システムを拡張しやすくなります。  
* **柔軟性:** さまざまなデータ形式（JSON, XMLなど）をサポートでき、多様なクライアント（ウェブブラウザ、モバイルアプリなど）に対応できます。  
* **独立性:** クライアントとサーバーが分離しているため、それぞれの開発を独立して進められます。  
* **可視性:** URIやHTTPメソッドを通じて、APIの機能が比較的明確に分かります。

### **7.2. デメリット**

* **ステートレス性の制約:** サーバーが状態を保持しないため、状態管理が必要な場合はクライアント側で工夫が必要です。  
* **統一インターフェースの学習コスト:** HATEOASなど、RESTの原則を完全に理解し適用するには学習コストがかかる場合があります。  
* **オーバーフェッチ・アンダーフェッチ:** 固定されたリソース構造のため、クライアントが必要としないデータまで取得してしまう（オーバーフェッチ）、または複数のリクエストが必要になる（アンダーフェッチ）場合があります。 (GraphQLなどの技術で解決が図られることもあります)  
* **HTTPメソッドの制約:** HTTPメソッドの種類が限られているため、複雑な操作を表現しにくい場合があります。

## **8\. まとめ**

RESTful APIは、現代のウェブサービス開発において不可欠な技術です。その原則を理解し、適切に設計することで、柔軟でスケーラブルなシステムを構築することができます。

